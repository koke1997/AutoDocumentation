# autodocumentation/generators/sphinx_generator.py
import os
import re
from typing import Dict, List, Any

class SphinxGenerator:
    """Generates Sphinx documentation from parsed code."""
    
    def __init__(self, output_dir: str):
        """
        Initialize the Sphinx generator.
        
        Args:
            output_dir: Directory where documentation will be generated
        """
        self.output_dir = output_dir
        self.api_dir = os.path.join(output_dir, 'api')
        os.makedirs(self.api_dir, exist_ok=True)
    
    def generate_from_parsed_code(self, parsed_code: Dict[str, Any], 
                                  documentation: str) -> str:
        """
        Generate Sphinx documentation from parsed code and LLM output.
        
        Args:
            parsed_code: Dictionary of parsed code information
            documentation: Documentation text generated by Claude
            
        Returns:
            Path to the generated documentation file
        """
        module_name = os.path.basename(parsed_code['file_path']).replace('.py', '')
        output_file = os.path.join(self.api_dir, f"{module_name}.rst")
        
        # Ensure the documentation is in RST format
        if not self._is_rst_format(documentation):
            documentation = self._convert_to_rst(documentation, parsed_code)
        
        # Add auto-generated admonition to the top
        documentation = self._add_autogenerated_notice(documentation)
        
        # Add structured API documentation
        documentation = self._add_api_structure(documentation, parsed_code)
        
        # Write the documentation to file
        with open(output_file, 'w') as f:
            f.write(documentation)
        
        # Update index file
        self._update_index_file(module_name)
        
        return output_file
    
    def _is_rst_format(self, text: str) -> bool:
        """Check if text appears to be in reStructuredText format."""
        # Very basic check, can be improved
        rst_indicators = [
            "===+", "---+", "~~~+", "^\.\. [a-z]+::",
            "^\.\. code-block::", "^\.\. note::", "^\.\. warning::"
        ]
        pattern = "|".join(rst_indicators)
        return bool(re.search(pattern, text, re.MULTILINE))
    
    def _convert_to_rst(self, text: str, parsed_code: Dict[str, Any]) -> str:
        """Convert text (likely Markdown) to reStructuredText."""
        # This is a simplified version - in practice, you might want to use
        # a proper Markdown to RST converter or ask Claude to convert it
        
        module_name = os.path.basename(parsed_code['file_path']).replace('.py', '')
        
        # Create title and heading
        rst = f"{module_name}\n"
        rst += "=" * len(module_name) + "\n\n"
        
        # Add the documentation text (assuming it's already RST or close enough)
        rst += text
        
        # Replace common Markdown elements with RST
        # Convert code blocks
        rst = re.sub(r'```(\w+)\n(.*?)```', r'.. code-block:: \1\n\n\2', rst, flags=re.DOTALL)
        
        # Convert headers
        rst = re.sub(r'^# (.*?)$', r'\1\n=====', rst, flags=re.MULTILINE)
        rst = re.sub(r'^## (.*?)$', r'\1\n-----', rst, flags=re.MULTILINE)
        rst = re.sub(r'^### (.*?)$', r'\1\n~~~~~', rst, flags=re.MULTILINE)
        
        # Convert links
        rst = re.sub(r'\[(.*?)\]\((.*?)\)', r'`\1 <\2>`_', rst)
        
        return rst
    
    def _add_autogenerated_notice(self, documentation: str) -> str:
        """Add a notice that the documentation was auto-generated."""
        notice = ".. note::\n   This documentation was auto-generated using Claude.\n\n"
        return notice + documentation
    
    def _add_api_structure(self, documentation: str, parsed_code: Dict[str, Any]) -> str:
        """Add structured API documentation based on parsed code."""
        module_name = os.path.basename(parsed_code['file_path']).replace('.py', '')
        
        api_doc = f"\nAPI Reference\n-------------\n\n"
        
        # Add module information
        api_doc += f".. py:module:: {module_name}\n\n"
        
        # Add classes
        for class_info in parsed_code.get('classes', []):
            class_name = class_info['name']
            api_doc += f".. py:class:: {class_name}\n\n"
            
            if class_info.get('docstring'):
                api_doc += f"   {class_info['docstring']}\n\n"
            
            # Add methods
            for method in class_info.get('methods', []):
                method_name = method['name']
                params = ", ".join([p['name'] for p in method.get('parameters', [])])
                api_doc += f"   .. py:method:: {method_name}({params})\n\n"
                
                if method.get('docstring'):
                    api_doc += f"      {method['docstring']}\n\n"
        
        # Add functions
        for func_info in parsed_code.get('functions', []):
            func_name = func_info['name']
            params = ", ".join([p['name'] for p in func_info.get('parameters', [])])
            api_doc += f".. py:function:: {func_name}({params})\n\n"
            
            if func_info.get('docstring'):
                api_doc += f"   {func_info['docstring']}\n\n"
        
        # Append the API documentation to the end
        return documentation + "\n\n" + api_doc
    
    def _update_index_file(self, module_name: str) -> None:
        """Update the index.rst file to include the new module."""
        index_file = os.path.join(self.api_dir, 'index.rst')
        
        # Create index file if it doesn't exist
        if not os.path.exists(index_file):
            with open(index_file, 'w') as f:
                f.write("API Reference\n=============\n\n")
                f.write(".. toctree::\n   :maxdepth: 2\n\n")
                f.write(f"   {module_name}\n")
        else:
            # Read the index file
            with open(index_file, 'r') as f:
                content = f.read()
            
            # Check if the module is already in the toctree
            if f"   {module_name}\n" not in content:
                # Find the toctree directive
                toctree_match = re.search(r'.. toctree::(.*?)(\n\n|\Z)', content, re.DOTALL)
                if toctree_match:
                    # Append the module to the toctree
                    toctree_content = toctree_match.group(1)
                    new_toctree = toctree_content + f"\n   {module_name}"
                    new_content = content.replace(toctree_match.group(0), 
                                                f".. toctree::{new_toctree}\n\n")
                    
                    # Write the updated content
                    with open(index_file, 'w') as f:
                        f.write(new_content)
                else:
                    # If toctree directive not found, append it
                    with open(index_file, 'a') as f:
                        f.write("\n\n.. toctree::\n   :maxdepth: 2\n\n")
                        f.write(f"   {module_name}\n")
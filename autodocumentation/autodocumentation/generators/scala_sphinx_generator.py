# autodocumentation/generators/scala_sphinx_generator.py
import os
import re
from typing import Dict, List, Any

class ScalaSphinxGenerator:
    """Generates Sphinx documentation specifically for Scala code."""
    
    def __init__(self, output_dir: str):
        """
        Initialize the Scala Sphinx generator.
        
        Args:
            output_dir: Directory where documentation will be generated
        """
        self.output_dir = output_dir
        self.api_dir = os.path.join(output_dir, 'api', 'scala')
        os.makedirs(self.api_dir, exist_ok=True)
    
    def generate_from_parsed_code(self, parsed_code: Dict[str, Any], 
                                 documentation: str) -> str:
        """
        Generate Sphinx documentation from parsed Scala code and LLM output.
        
        Args:
            parsed_code: Dictionary of parsed code information
            documentation: Documentation text generated by Claude
            
        Returns:
            Path to the generated documentation file
        """
        module_name = os.path.basename(parsed_code['file_path']).replace('.scala', '')
        output_file = os.path.join(self.api_dir, f"{module_name}.rst")
        
        # Ensure the documentation is in RST format
        if not self._is_rst_format(documentation):
            documentation = self._convert_to_rst(documentation, parsed_code)
        
        # Add auto-generated admonition to the top
        documentation = self._add_autogenerated_notice(documentation)
        
        # Add structured API documentation
        documentation = self._add_api_structure(documentation, parsed_code)
        
        # Write the documentation to file
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(documentation)
        
        # Update index file
        self._update_index_file(module_name)
        
        return output_file
    
    def _is_rst_format(self, text: str) -> bool:
        """Check if text appears to be in reStructuredText format."""
        # Very basic check
        rst_indicators = [
            "===+", "---+", "~~~+", "^\.\. [a-z]+::",
            "^\.\. code-block::", "^\.\. note::", "^\.\. warning::"
        ]
        pattern = "|".join(rst_indicators)
        return bool(re.search(pattern, text, re.MULTILINE))
    
    def _convert_to_rst(self, text: str, parsed_code: Dict[str, Any]) -> str:
        """Convert text (likely Markdown) to reStructuredText."""
        # This is a simplified version
        
        module_name = os.path.basename(parsed_code['file_path']).replace('.scala', '')
        
        # Create title and heading
        rst = f"{module_name}\n"
        rst += "=" * len(module_name) + "\n\n"
        
        # Add package information
        if parsed_code.get('package'):
            rst += f"**Package:** ``{parsed_code['package']}``\n\n"
        
        # Add the documentation text
        rst += text
        
        # Replace common Markdown elements with RST
        # Convert code blocks
        rst = re.sub(r'```(\w+)\n(.*?)```', r'.. code-block:: \1\n\n\2', rst, flags=re.DOTALL)
        
        # Convert headers
        rst = re.sub(r'^# (.*?)$', r'\1\n=====', rst, flags=re.MULTILINE)
        rst = re.sub(r'^## (.*?)$', r'\1\n-----', rst, flags=re.MULTILINE)
        rst = re.sub(r'^### (.*?)$', r'\1\n~~~~~', rst, flags=re.MULTILINE)
        
        # Convert links
        rst = re.sub(r'\[(.*?)\]\((.*?)\)', r'`\1 <\2>`_', rst)
        
        return rst
    
    def _add_autogenerated_notice(self, documentation: str) -> str:
        """Add a notice that the documentation was auto-generated."""
        notice = ".. note::\n   This documentation was auto-generated using Claude.\n\n"
        return notice + documentation
    
    def _add_api_structure(self, documentation: str, parsed_code: Dict[str, Any]) -> str:
        """Add structured API documentation based on parsed Scala code."""
        module_name = os.path.basename(parsed_code['file_path']).replace('.scala', '')
        
        api_doc = f"\nAPI Reference\n-------------\n\n"
        
        # Add module/package information
        if parsed_code.get('package'):
            api_doc += f"**Package:** ``{parsed_code['package']}``\n\n"
        
        # Add imports
        if parsed_code.get('imports'):
            api_doc += "**Imports:**\n\n"
            for imp in parsed_code['imports']:
                api_doc += f"* ``import {imp['statement']}``\n"
            api_doc += "\n"
        
        # Add classes
        for class_info in parsed_code.get('classes', []):
            class_name = class_info['name']
            type_params = f"[{class_info['type_parameters']}]" if class_info.get('type_parameters') else ""
            
            api_doc += f"Class ``{class_name}{type_params}``\n"
            api_doc += "~" * (len(class_name) + len(type_params) + 9) + "\n\n"
            
            if class_info.get('javadoc'):
                api_doc += f"{class_info['javadoc']}\n\n"
            
            # Add constructor parameters
            if class_info.get('constructor_parameters'):
                api_doc += "**Constructor Parameters:**\n\n"
                for param in class_info['constructor_parameters']:
                    api_doc += f"* ``{param['name']}``: {param.get('type', '')}\n"
                api_doc += "\n"
            
            # Add fields
            if class_info.get('fields'):
                api_doc += "**Fields:**\n\n"
                for field in class_info['fields']:
                    field_type = field.get('field_type', 'val')
                    data_type = f": {field['data_type']}" if field.get('data_type') else ""
                    api_doc += f"* ``{field_type} {field['name']}{data_type}``\n"
                    if field.get('javadoc'):
                        api_doc += f"  {field['javadoc']}\n"
                api_doc += "\n"
            
            # Add methods
            if class_info.get('methods'):
                api_doc += "**Methods:**\n\n"
                for method in class_info['methods']:
                    method_name = method['name']
                    type_params = f"[{method['type_parameters']}]" if method.get('type_parameters') else ""
                    
                    # Format parameters
                    param_str = ""
                    if method.get('parameters'):
                        param_parts = []
                        for param in method['parameters']:
                            param_type = f": {param['type']}" if param.get('type') else ""
                            param_parts.append(f"{param['name']}{param_type}")
                        param_str = ", ".join(param_parts)
                    
                    return_type = f": {method['return_type']}" if method.get('return_type') else ""
                    
                    api_doc += f"* ``def {method_name}{type_params}({param_str}){return_type}``\n"
                    if method.get('javadoc'):
                        api_doc += f"  {method['javadoc']}\n"
                api_doc += "\n"
        
        # Add objects
        for object_info in parsed_code.get('objects', []):
            object_name = object_info['name']
            
            api_doc += f"Object ``{object_name}``\n"
            api_doc += "~" * (len(object_name) + 10) + "\n\n"
            
            if object_info.get('javadoc'):
                api_doc += f"{object_info['javadoc']}\n\n"
            
            # Add fields
            if object_info.get('fields'):
                api_doc += "**Fields:**\n\n"
                for field in object_info['fields']:
                    field_type = field.get('field_type', 'val')
                    data_type = f": {field['data_type']}" if field.get('data_type') else ""
                    api_doc += f"* ``{field_type} {field['name']}{data_type}``\n"
                    if field.get('javadoc'):
                        api_doc += f"  {field['javadoc']}\n"
                api_doc += "\n"
            
            # Add methods
            if object_info.get('methods'):
                api_doc += "**Methods:**\n\n"
                for method in object_info['methods']:
                    method_name = method['name']
                    type_params = f"[{method['type_parameters']}]" if method.get('type_parameters') else ""
                    
                    # Format parameters
                    param_str = ""
                    if method.get('parameters'):
                        param_parts = []
                        for param in method['parameters']:
                            param_type = f": {param['type']}" if param.get('type') else ""
                            param_parts.append(f"{param['name']}{param_type}")
                        param_str = ", ".join(param_parts)
                    
                    return_type = f": {method['return_type']}" if method.get('return_type') else ""
                    
                    api_doc += f"* ``def {method_name}{type_params}({param_str}){return_type}``\n"
                    if method.get('javadoc'):
                        api_doc += f"  {method['javadoc']}\n"
                api_doc += "\n"
        
        # Add traits
        for trait_info in parsed_code.get('traits', []):
            trait_name = trait_info['name']
            type_params = f"[{trait_info['type_parameters']}]" if trait_info.get('type_parameters') else ""
            
            api_doc += f"Trait ``{trait_name}{type_params}``\n"
            api_doc += "~" * (len(trait_name) + len(type_params) + 9) + "\n\n"
            
            if trait_info.get('javadoc'):
                api_doc += f"{trait_info['javadoc']}\n\n"
            
            # Add methods
            if trait_info.get('methods'):
                api_doc += "**Methods:**\n\n"
                for method in trait_info['methods']:
                    method_name = method['name']
                    type_params = f"[{method['type_parameters']}]" if method.get('type_parameters') else ""
                    
                    # Format parameters
                    param_str = ""
                    if method.get('parameters'):
                        param_parts = []
                        for param in method['parameters']:
                            param_type = f": {param['type']}" if param.get('type') else ""
                            param_parts.append(f"{param['name']}{param_type}")
                        param_str = ", ".join(param_parts)
                    
                    return_type = f": {method['return_type']}" if method.get('return_type') else ""
                    
                    api_doc += f"* ``def {method_name}{type_params}({param_str}){return_type}``\n"
                    if method.get('javadoc'):
                        api_doc += f"  {method['javadoc']}\n"
                api_doc += "\n"
        
        # Append the API documentation to the end
        return documentation + "\n\n" + api_doc
    
    def _update_index_file(self, module_name: str) -> None:
        """Update the index.rst file to include the new module."""
        index_file = os.path.join(self.api_dir, 'index.rst')
        
        # Create index file if it doesn't exist
        if not os.path.exists(index_file):
            os.makedirs(os.path.dirname(index_file), exist_ok=True)
            with open(index_file, 'w', encoding='utf-8') as f:
                f.write("Scala API Reference\n=================\n\n")
                f.write(".. toctree::\n   :maxdepth: 2\n\n")
                f.write(f"   {module_name}\n")
        else:
            # Read the index file
            with open(index_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Check if the module is already in the toctree
            if f"   {module_name}\n" not in content:
                # Find the toctree directive
                toctree_match = re.search(r'.. toctree::(.*?)(\n\n|\Z)', content, re.DOTALL)
                if toctree_match:
                    # Append the module to the toctree
                    toctree_content = toctree_match.group(1)
                    new_toctree = toctree_content + f"\n   {module_name}"
                    new_content = content.replace(toctree_match.group(0), 
                                                f".. toctree::{new_toctree}\n\n")
                    
                    # Write the updated content
                    with open(index_file, 'w', encoding='utf-8') as f:
                        f.write(new_content)
                else:
                    # If toctree directive not found, append it
                    with open(index_file, 'a', encoding='utf-8') as f:
                        f.write("\n\n.. toctree::\n   :maxdepth: 2\n\n")
                        f.write(f"   {module_name}\n")
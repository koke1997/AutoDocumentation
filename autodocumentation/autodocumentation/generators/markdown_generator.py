# autodocumentation/generators/markdown_generator.py
import os
import re
from typing import Dict, List, Any

class MarkdownGenerator:
    """Generates Markdown documentation from parsed code."""
    
    def __init__(self, output_dir: str):
        """
        Initialize the Markdown generator.
        
        Args:
            output_dir: Directory where documentation will be generated
        """
        self.output_dir = output_dir
        self.api_dir = os.path.join(output_dir, 'api')
        os.makedirs(self.api_dir, exist_ok=True)
    
    def generate_from_parsed_code(self, parsed_code: Dict[str, Any], 
                                 documentation: str) -> str:
        """
        Generate Markdown documentation from parsed code and LLM output.
        
        Args:
            parsed_code: Dictionary of parsed code information
            documentation: Documentation text generated by Claude
            
        Returns:
            Path to the generated documentation file
        """
        file_path = parsed_code['file_path']
        file_ext = os.path.splitext(file_path)[1]
        module_name = os.path.basename(file_path).replace(file_ext, '')
        output_file = os.path.join(self.api_dir, f"{module_name}.md")
        
        # Ensure the documentation is in Markdown format
        if not self._is_markdown_format(documentation):
            documentation = self._convert_to_markdown(documentation, parsed_code)
        
        # Add auto-generated notice to the top
        documentation = self._add_autogenerated_notice(documentation)
        
        # Write the documentation to file
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(documentation)
        
        # Update index file
        self._update_index_file(module_name)
        
        return output_file
    
    def _is_markdown_format(self, text: str) -> bool:
        """Check if text appears to be in Markdown format."""
        # Basic check for markdown indicators
        markdown_indicators = [
            r'^#+\s+.+$',  # Headers
            r'^-\s+.+$',   # List items
            r'^\*\s+.+$',  # List items
            r'^\d+\.\s+.+$', # Numbered lists
            r'^\[.*\]\(.*\)', # Links
            r'^```.*```',  # Code blocks (simple check)
            r'\*\*.*\*\*', # Bold text
            r'_.*_',       # Italic text
        ]
        pattern = '|'.join(markdown_indicators)
        return bool(re.search(pattern, text, re.MULTILINE))
    
    def _convert_to_markdown(self, text: str, parsed_code: Dict[str, Any]) -> str:
        """Convert text to Markdown if needed."""
        # If it looks like RST, convert it to Markdown
        if '.. code-block::' in text or '====' in text:
            # Convert RST to Markdown (simplified)
            # Headers
            text = re.sub(r'^(.*)\n=+\n', r'# \1\n', text, flags=re.MULTILINE)
            text = re.sub(r'^(.*)\n-+\n', r'## \1\n', text, flags=re.MULTILINE)
            
            # Code blocks
            text = re.sub(r'\.\. code-block:: (\w+)\n\n((?:\s+.+\n)+)', 
                         r'```\1\n\2\n```', text, flags=re.MULTILINE)
            
            # Notes/warnings
            text = re.sub(r'\.\. note::\n\s+(.*)', r'> **Note:** \1', text, flags=re.MULTILINE)
            text = re.sub(r'\.\. warning::\n\s+(.*)', r'> **Warning:** \1', text, flags=re.MULTILINE)
            
            # Links
            text = re.sub(r'`(.*) <(.*)>`_', r'[\1](\2)', text)
            
        # Add a title if it doesn't have one
        module_name = os.path.basename(parsed_code['file_path'])
        if not text.startswith('# '):
            text = f"# {module_name}\n\n{text}"
            
        return text
    
    def _add_autogenerated_notice(self, documentation: str) -> str:
        """Add a notice that the documentation was auto-generated."""
        notice = "> *This documentation was auto-generated using Claude AI.*\n\n"
        return notice + documentation
    
    def _update_index_file(self, module_name: str) -> None:
        """Update the index.md file to include the new module."""
        index_file = os.path.join(self.api_dir, 'index.md')
        
        # Create index file if it doesn't exist
        if not os.path.exists(index_file):
            with open(index_file, 'w', encoding='utf-8') as f:
                f.write("# API Documentation\n\n")
                f.write("## Modules\n\n")
                f.write(f"* [{module_name}](./{module_name}.md)\n")
        else:
            # Read the index file
            with open(index_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # Check if the module is already in the list
            if f"[{module_name}](./{module_name}.md)" not in content:
                # Find the modules list
                modules_match = re.search(r'## Modules\n\n', content)
                if modules_match:
                    # Find the position to insert the new module
                    pos = modules_match.end()
                    # Insert the new module
                    new_content = content[:pos] + f"* [{module_name}](./{module_name}.md)\n" + content[pos:]
                    # Write the updated content
                    with open(index_file, 'w', encoding='utf-8') as f:
                        f.write(new_content)
                else:
                    # If modules list not found, append it
                    with open(index_file, 'a', encoding='utf-8') as f:
                        f.write("\n## Modules\n\n")
                        f.write(f"* [{module_name}](./{module_name}.md)\n")